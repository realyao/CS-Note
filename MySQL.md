- [据库三大范式是什么](#据库三大范式是什么)
- [超键、候选键、主键、外键（关系模型中）](#超键候选键主键外键关系模型中)
- [Mysql 权限表](#mysql-权限表)
- [Binlog的录入格式](#binlog的录入格式)
- [MySQL 存储引擎](#mysql-存储引擎)
  - [MyISAM 存储引擎](#myisam-存储引擎)
  - [InnoDB](#innodb)
    - [InnoDB 的事务隔离级别](#innodb-的事务隔离级别)
  - [Memory](#memory)
  - [MyISAM 与 InnoDB 区别 **](#myisam-与-innodb-区别-)
- [MySQL 锁](#mysql-锁)
- [索引](#索引)
  - [索引类型](#索引类型)


## 据库三大范式是什么

1. 第一范式：每一列属性都是不可再分的属性值，确保每一列的**原子性**
2. 第二范式：在第一范式的基础上，非主键列完全依赖于主键。数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为**主键**
3. 第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。数据不能存在传递关系，即**每个属性都跟主键有直接关系**而不是间接关系。像：a-->b-->c  属性之间含有这样的关系，是不符合第三范式的。

比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）

这样一个表结构，就存在上述关系。 学号--> 所在院校 --> (院校地址，院校电话)

这样的表结构，我们应该拆开来，如下。
（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）


```三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求>性能>表结构。所以不能一味的去追求范式建立数据库。```

## 超键、候选键、主键、外键（关系模型中）
- 超键（SK）：能唯一标识元组的属性集
- 候选键：能唯一标识元组 并且 不含多余属性 的属性集
- 主键（PK）：若干个候选键中随意指定一个作关键字，该关键字为PK
- 外键（FK）：关系模型$R_1$中的某属性不是$R_1$候选键，而是$R_2$中的候选键，则该属性集是$R_1$的外键
  
![keys](fig/sqlkey.jpg)


## Mysql 权限表
- user 权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局
级的。
- db 权限表：记录各个帐号在各个数据库上的操作权限。
- table_priv, columns_priv权限表：记录数据表级和列级的操作权限。
- host 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受 GRANT 和 REVOKE 语句的影响。

## Binlog的录入格式
binlog是记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。

1. **row** 级别下，不记录 SQL 语句上下文相关信息，仅保存哪条记录被修改。记录单元为**每一行的改动**，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如 alter table)，因此这种模式的文件保存的信息太多，日志量太大。

2. **statement** 模式下，每一条会修改数据的 **SQL** 都会记录在 Binlog 中。不需要记录每一行的变化，减少了 Binlog 日志量，节约了 IO，提高性能。由于sql 的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。

3. **mixed**，一种折中的方案，普通操作使用 statement 记录，当无法使用
statement 的时候使用 row。

## MySQL 存储引擎
### MyISAM 存储引擎
是早期默认引擎，**不支持事务和外键**，所以访问速度比较**快**。如果应用主要以读取和写入为主，只有少量的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择 MyISAM 存储引擎是非常适合的。
 
MyISAM 是在 Web 数据仓储和其他应用环境下最常使用的存储引擎之一。

### InnoDB
默认的事务型引擎。
InnoDB 存储引擎在事务上具有优势，即支持具有提交、回滚和崩溃恢复能力的事务安装，所以比 MyISAM 存储引擎**占用更多的磁盘空间**。

如果应用对**事务的完整性**有比较高的要求，在并发条件下要求**数据的一致性**，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎是比较合适的选择。
 
InnoDB 存储引擎除了可以有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback）。
对于类似计费系统或者`财务系统`等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。
> 事务（Transaction）：事务是一组SQL语句，要么全部执行成功，要么全部执行失败（原子的）。用于处理操作量大，复杂度高的数据。事务是必须满足4个条件（ACID）：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
#### InnoDB 的事务隔离级别
1. read uncommited：读到未提交数据
2. read committed：脏读，不可重复读
3. repeatable read：可重读
4. serializable：串行事物

### Memory
MEMORY 存储引擎将所有数据保存在 RAM 中，所以该存储引擎的数据访问速度快，但是安全上没有保障。
MEMORY 对表的大小有限制，太大的表无法缓存在内存中。由于使用 MEMORY 存储引擎没有安全保障，所以要确保数据库异常终止后表中的数据可以恢复。
 
如果应用中涉及**数据比较少**，且需要进行**快速访问**，则适合使用 MEMORY 存储引擎。

### MyISAM 与 InnoDB 区别 **
- 锁粒度不同，InnoDB 比 MyISAM 支持更高的并发。InnoDB 的锁粒度为行锁，开销大，但是能解决脏读和不可重复读的问题，相对来说也更容易发生死锁。
MyISAM 的锁粒度为表锁。

- InnoDB 是有事务日志的，崩溃等条件后，可以根据日志文件进行恢复
- 查询性能上:MylSAM 要优于 InnoDB。因为 InnoDB 在查询过程中，是需要维护数据缓存。
- 表结构差异：MyISAM 的表结构文件包括:frm(表结构定义),MYI(索引),MYD(数据);
  而 InnoDB 的表数据文件为:ibd 和 frm(表结构定义)。


## MySQL 锁
- **表**级锁：开销小，加锁快；不会死锁；锁定粒度大，发生锁冲突的概
率最高，并发度最低。
- **行**级锁：开销大，加锁慢；会死锁；锁定粒度最小，发生锁冲突的概
率最低，并发度也最高。
- **页面**锁：开销和加锁时间界于表锁和行锁之间；**会出现死锁**；锁定粒度界
于表锁和行锁之间，并发度一般。

## 索引
### 索引类型
- **主键**索引（PK）: 数据列不允许重复，不能为 NULL，一个表只能有一个主键。
- 唯一索引：数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。（往往用来避免数据重复）

```SQL
ALTER TABLE table_name ADD UNIQUE (column1,column2); 
```

- 普通索引：无唯一性限制，允许为 NULL 值。 `ADD INDEX`
- 全文索引：基于倒排索引技术（Inverted index）。
    - 倒排表
  
倒排表以字或词为关键字进行索引，表中关键字所对应的记录表项记录了出现这个字或词的所有文档，一个表项就是一个字表段，它记录该文档的ID和字符在该文档中出现的位置情况。

<img src="fig/sql1.jpg" width="50%"><img src="fig/sql2.jpg" width="50%">

```SQL
ALTER TABLE table_name ADD FULLTEXT (column);
-- 查询
select * from table_name where match(##,##) against(''xxxx)
```

